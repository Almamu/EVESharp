using System.Collections.Generic;
using EVE.Packets.Complex;
using Node.Inventory;
using Node.Notifications;
using Node.Notifications.Nodes;
using PythonTypes.Types.Collections;
using PythonTypes.Types.Network;
using PythonTypes.Types.Primitives;

namespace Node.Network
{
    public class NotificationManager
    {
        /// <summary>
        /// idType to use when notificating characters
        /// </summary>
        private const string NOTIFICATION_TYPE_CHARACTER = "charid";
        /// <summary>
        /// idType to use when notificating corporations
        /// </summary>
        private const string NOTIFICATION_TYPE_CORPORATON = "corpid";
        /// <summary>
        /// idType to use when notificating stations
        /// </summary>
        private const string NOTIFICATION_TYPE_STATION = "stationid";
        /// <summary>
        /// idType to use when notificating owners (corporation, character, alliances...)
        /// </summary>
        private const string NOTIFICATION_TYPE_OWNER = "ownerid";
        /// <summary>
        /// idType to use when notificating owners (corporation, character, alliances...) at a specific station
        /// </summary>
        private const string NOTIFICATION_TYPE_OWNER_LOCATIONID = "ownerid&locationid";
        
        /// <summary>
        /// The connection this notification manager is using to send notifications through
        /// </summary>
        public ClusterConnection ClusterConnection { get; }
        
        /// <summary>
        /// The node this notification manager belongs to
        /// </summary>
        public NodeContainer Container { get; }
        
        /// <summary>
        /// The client manager used by this notification manager to decide whether to send a notification or not
        /// </summary>
        public ClientManager ClientManager { get; }
        
        /// <summary>
        /// The character manager used by this notification manager to decide whether to send a notification or not
        /// </summary>
        public CharacterManager CharacterManager { get; }
        
        public NotificationManager(ClusterConnection clusterConnection, NodeContainer container, ClientManager clientManager, CharacterManager characterManager)
        {
            this.ClusterConnection = clusterConnection;
            this.Container = container;
            this.ClientManager = clientManager;
            this.CharacterManager = characterManager;
        }

        public void NotifyCharacters(PyList<PyInteger> characterIDs, string type, PyTuple notification)
        {
            // multiple notifications are not checked as the traffic generated by these is usually less
            // inside our network
            this.SendNotification(type, NOTIFICATION_TYPE_CHARACTER, characterIDs, notification);
        }

        public void NotifyCharacter(int characterID, string type, PyTuple notification)
        {
            // do not waste network resources on useless notifications
            if (this.CharacterManager.IsCharacterConnected(characterID) == false)
                return;

            this.SendNotification(type, NOTIFICATION_TYPE_CHARACTER, characterID, notification);
        }

        public void NotifyCharacters(PyList<PyInteger> characterIDs, ClientNotification notification)
        {
            this.SendNotification(NOTIFICATION_TYPE_CHARACTER, characterIDs, notification);
        }
        
        public void NotifyCharacter(int characterID, ClientNotification entry)
        {
            // do not waste network resources on useless notifications
            if (this.CharacterManager.IsCharacterConnected(characterID) == false)
                return;
            
            // build a proper notification for this
            this.SendNotification(NOTIFICATION_TYPE_CHARACTER, characterID, entry);
        }

        public void NotifyOwner(int ownerID, ClientNotification entry)
        {
            this.SendNotification(NOTIFICATION_TYPE_OWNER, ownerID, entry);
        }

        public void NotifyOwnerAtLocation(int ownerID, int locationID, ClientNotification entry)
        {
            this.SendNotification(NOTIFICATION_TYPE_OWNER_LOCATIONID, new PyTuple(2) {[0] = ownerID, [1] = locationID}, entry);
        }
        public void NotifyCorporation(int corporationID, string type, PyTuple notification)
        {
            this.SendNotification(type, NOTIFICATION_TYPE_CORPORATON, corporationID, notification);
        }

        public void NotifyCorporation(int corporationID, ClientNotification notification)
        {
            this.SendNotification(NOTIFICATION_TYPE_CORPORATON, corporationID, notification);
        }

        public void NotifyStation(int stationID, string type, PyTuple notification)
        {
            this.SendNotification(type, NOTIFICATION_TYPE_STATION, stationID, notification);
        }

        public void NotifyStation(int stationID, ClientNotification notification)
        {
            this.SendNotification(NOTIFICATION_TYPE_STATION, stationID, notification);
        }

        /// <summary>
        /// Send a notification to the given node
        /// </summary>
        /// <param name="nodeID">The node to notify</param>
        /// <param name="notification">The notification to send</param>
        public void NotifyNode(long nodeID, InterNodeNotification notification)
        {
            // do not notify if the notification is for a non-existant node (nodeID = 0)
            if (nodeID == 0)
                return;
            
            PyPacket packet = new PyPacket(PyPacket.PacketType.NOTIFICATION)
            {
                Source = new PyAddressAny(0),
                Destination = new PyAddressBroadcast(new PyList(1) {[0] = nodeID}, "nodeid"),
                Payload = notification,
                OutOfBounds = new PyDictionary(),
                
                // set the userID to -1, this will indicate the cluster controller to fill it in
                UserID = -1
            };

            this.ClusterConnection.Send(packet);
        }

        public void SendNotification(string idType, int id, ClientNotification data)
        {
            this.SendNotification(data.NotificationName, idType, new PyList(1) {[0] = id}, data.GetElements());
        }

        public void SendNotification(string idType, PyTuple id, ClientNotification data)
        {
            this.SendNotification(data.NotificationName, idType, new PyList(1) { [0] = id}, data.GetElements());
        }

        public void SendNotification(string notificationType, string idType, int id, PyTuple data)
        {
            this.SendNotification(notificationType, idType, new PyList(1) {[0] = id}, data);
        }

        public void SendNotification(string idType, PyList idsOfInterest, ClientNotification data)
        {
            this.SendNotification(data.NotificationName, idType, idsOfInterest, data.GetElements());
        }
        
        public void SendNotification(string notificationType, string idType, PyList idsOfInterest, PyTuple data)
        {
            PyTuple dataContainer = new PyTuple(2)
            {
                [0] = 1,
                [1] = data
            };

            dataContainer = new PyTuple(2)
            {
                [0] = 0,
                [1] = dataContainer
            };

            dataContainer = new PyTuple(2)
            {
                [0] = 0,
                [1] = new PySubStream(dataContainer)
            };

            dataContainer = new PyTuple(2)
            {
                [0] = dataContainer,
                [1] = null
            };

            PyPacket packet = new PyPacket(PyPacket.PacketType.NOTIFICATION)
            {
                Destination = new PyAddressBroadcast(idsOfInterest, idType, notificationType),
                Source = new PyAddressNode(this.Container.NodeID),
                
                // set the userID to -1, this will indicate the cluster controller to fill it in
                UserID = -1,
                Payload = dataContainer
            };
            
            this.ClusterConnection.Send(packet);
        }
    }
}